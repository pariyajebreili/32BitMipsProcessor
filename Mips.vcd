$date
	Thu Jun 16 18:41:45 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module tb_mips $end
$var wire 1 ! zero $end
$var wire 5 " write_reg [4:0] $end
$var wire 32 # write_data_reg [31:0] $end
$var wire 32 $ read_data2 [31:0] $end
$var wire 32 % read_data1 [31:0] $end
$var wire 32 & read_data [31:0] $end
$var wire 32 ' pc_next [31:0] $end
$var wire 32 ( pc_in [31:0] $end
$var wire 32 ) inst [31:0] $end
$var wire 4 * alu_crtl [3:0] $end
$var reg 1 + clk $end
$var reg 1 , rst $end
$var integer 32 - i [31:0] $end
$scope module mcpu $end
$var wire 1 . bne_zero_and $end
$var wire 1 / branch_zero_and $end
$var wire 1 0 branching $end
$var wire 1 + clk $end
$var wire 1 , rst $end
$var wire 1 ! zero $end
$var wire 5 1 write_reg [4:0] $end
$var wire 32 2 write_data_reg [31:0] $end
$var wire 32 3 shift_out [31:0] $end
$var wire 1 4 reg_write $end
$var wire 1 5 reg_dst $end
$var wire 32 6 read_data2 [31:0] $end
$var wire 32 7 read_data1 [31:0] $end
$var wire 32 8 read_data [31:0] $end
$var wire 32 9 pc_out_alu [31:0] $end
$var wire 32 : pc_next [31:0] $end
$var wire 32 ; pc_in [31:0] $end
$var wire 1 < mem_write $end
$var wire 1 = mem_toreg $end
$var wire 1 > mem_read $end
$var wire 1 ? j $end
$var wire 32 @ inst [31:0] $end
$var wire 32 A extend32 [31:0] $end
$var wire 1 B branch_ne $end
$var wire 1 C branch $end
$var wire 1 D alu_src $end
$var wire 32 E alu_out [31:0] $end
$var wire 4 F alu_op [3:0] $end
$var wire 4 G alu_crtl [3:0] $end
$var wire 32 H alu_b [31:0] $end
$var wire 32 I add_alu_out [31:0] $end
$scope module ADDRESS $end
$var wire 1 ! zero $end
$var wire 4 J alu_crtl [3:0] $end
$var wire 32 K B [31:0] $end
$var wire 32 L A [31:0] $end
$var reg 32 M alu_out [31:0] $end
$upscope $end
$scope module ADD_ALU_B $end
$var wire 32 N ShiftIn [31:0] $end
$var reg 32 O shift_out [31:0] $end
$upscope $end
$scope module AFT_RF $end
$var wire 32 P read_data2 [31:0] $end
$var wire 32 Q extend32 [31:0] $end
$var wire 1 D alu_src $end
$var reg 32 R alu_b [31:0] $end
$upscope $end
$scope module ALUCTRL $end
$var wire 6 S ADD [5:0] $end
$var wire 6 T AND [5:0] $end
$var wire 6 U OR [5:0] $end
$var wire 6 V SUB [5:0] $end
$var wire 6 W func [5:0] $end
$var wire 4 X alu_op [3:0] $end
$var reg 4 Y alu_crtl [3:0] $end
$upscope $end
$scope module BEF_RF $end
$var wire 5 Z rd [15:11] $end
$var wire 5 [ rt [20:16] $end
$var wire 1 5 reg_dst $end
$var reg 5 \ write_reg [4:0] $end
$upscope $end
$scope module CONTROL $end
$var wire 6 ] ADDI [5:0] $end
$var wire 6 ^ ANDI [5:0] $end
$var wire 6 _ BEQ [5:0] $end
$var wire 6 ` J [5:0] $end
$var wire 6 a LW [5:0] $end
$var wire 6 b ORI [5:0] $end
$var wire 6 c RTYPE [5:0] $end
$var wire 6 d SUBI [5:0] $end
$var wire 6 e SW [5:0] $end
$var wire 6 f opcode [5:0] $end
$var reg 4 g alu_op [3:0] $end
$var reg 1 D alu_src $end
$var reg 1 C branch $end
$var reg 1 B branch_ne $end
$var reg 1 ? j $end
$var reg 1 > mem_read $end
$var reg 1 = mem_toreg $end
$var reg 1 < mem_write $end
$var reg 1 5 reg_dst $end
$var reg 1 4 reg_write $end
$upscope $end
$scope module DM $end
$var wire 32 h addr [31:0] $end
$var wire 1 + clk $end
$var wire 1 > mem_read $end
$var wire 1 < mem_write $end
$var wire 32 i write_data [31:0] $end
$var reg 32 j read_data [31:0] $end
$var integer 32 k i [31:0] $end
$upscope $end
$scope module IM $end
$var wire 1 + clk $end
$var wire 32 l address [31:0] $end
$var reg 32 m inst [31:0] $end
$upscope $end
$scope module JUPM $end
$var wire 1 ? j $end
$var wire 32 n read_data1 [31:0] $end
$var wire 32 o pc_out_alu [31:0] $end
$var reg 32 p pc_in [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 + clk $end
$var wire 32 q pc_in [31:0] $end
$var wire 1 , rst $end
$var reg 32 r pc_next [31:0] $end
$upscope $end
$scope module PCADDER $end
$var wire 32 s pc_next [31:0] $end
$var wire 32 t shift_out [31:0] $end
$var reg 32 u add_alu_out [31:0] $end
$upscope $end
$scope module RF $end
$var wire 1 + clk $end
$var wire 32 v read_data1 [31:0] $end
$var wire 32 w read_data2 [31:0] $end
$var wire 5 x read_reg1 [4:0] $end
$var wire 5 y read_reg2 [4:0] $end
$var wire 1 4 reg_write $end
$var wire 5 z write_reg [4:0] $end
$var wire 32 { write_data [31:0] $end
$upscope $end
$scope module SE16TO32 $end
$var wire 16 | in16 [15:0] $end
$var reg 32 } out32 [31:0] $end
$upscope $end
$scope module mu3_0 $end
$var wire 32 ~ alu_out [31:0] $end
$var wire 1 = mem_toreg $end
$var wire 32 !" read_data [31:0] $end
$var reg 32 "" write_data_reg [31:0] $end
$upscope $end
$scope module mux4_0 $end
$var wire 32 #" add_alu_out [31:0] $end
$var wire 1 0 branch_zero_and $end
$var wire 32 $" pc_next [31:0] $end
$var reg 32 %" pc_in [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 %"
b0 $"
bx #"
bx ""
b0 !"
bx ~
bx }
bx |
bx {
bx z
bx y
bx x
bx w
bx v
bx u
bx t
b0 s
b0 r
b0 q
b0 p
b0 o
bx n
bx m
b0 l
b100000000 k
b0 j
bx i
bx h
bx g
bx f
b101011 e
b100111 d
b0 c
b110010 b
b100011 a
b10 `
b100 _
b101111 ^
b1000 ]
bx \
bx [
bx Z
bx Y
bx X
bx W
b100010 V
b100101 U
b100100 T
b100000 S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
0D
0C
xB
bx A
bx @
0?
0>
0=
0<
b0 ;
b0 :
b0 9
b0 8
bx 7
bx 6
05
04
bx 3
bx 2
bx 1
x0
0/
x.
bx -
1,
1+
bx *
bx )
b0 (
b0 '
b0 &
bx %
bx $
bx #
bx "
x!
$end
#50
0+
b0 -
0,
#100
b100 (
b100 ;
b100 l
b100 p
b100 q
b100 9
b100 o
b100 %"
b100 '
b100 :
b100 r
b100 s
b100 $"
1+
b1 -
#150
0+
b10 -
#200
b1000000010001000 I
b1000000010001000 u
b1000000010001000 #"
b1000 (
b1000 ;
b1000 l
b1000 p
b1000 q
b1000000010000000 3
b1000000010000000 O
b1000000010000000 t
b10100 #
b10100 2
b10100 {
b10100 ""
b10000000100000 A
b10000000100000 N
b10000000100000 Q
b10000000100000 }
b100 "
b100 1
b100 \
b100 z
b10 *
b10 G
b10 J
b10 Y
b1111 F
b1111 X
b1111 g
14
15
b100 H
b100 K
b100 R
b1000 9
b1000 o
b1000 %"
x0
x.
0!
b10100 E
b10100 M
b10100 h
b10100 ~
b10000000100000 |
b100 Z
b1 [
b100000 W
b0 f
b100 $
b100 6
b100 P
b100 i
b100 w
b1 y
b10000 %
b10000 7
b10000 L
b10000 n
b10000 v
b100 x
b1000 '
b1000 :
b1000 r
b1000 s
b1000 $"
b100000010010000000100000 )
b100000010010000000100000 @
b100000010010000000100000 m
1+
b11 -
#250
0+
b100 -
#300
b1100 (
b1100 ;
b1100 l
b1100 p
b1100 q
x0
x.
b1100 3
b1100 O
b1100 t
0!
b11 A
b11 N
b11 Q
b11 }
b101 "
b101 1
b101 \
b101 z
b10 *
b10 G
b10 J
b10 Y
b0 F
b0 X
b0 g
1<
1>
1D
14
05
b11 H
b11 K
b11 R
b11000 I
b11000 u
b11000 #"
b1100 9
b1100 o
b1100 %"
b11 |
b0 Z
b101 [
b11 W
b100011 f
b10000 $
b10000 6
b10000 P
b10000 i
b10000 w
b101 y
b1 x
b111 #
b111 2
b111 {
b111 ""
b10001100001001010000000000000011 )
b10001100001001010000000000000011 @
b10001100001001010000000000000011 m
b1100 '
b1100 :
b1100 r
b1100 s
b1100 $"
b111 E
b111 M
b111 h
b111 ~
b100 %
b100 7
b100 L
b100 n
b100 v
1+
b101 -
#350
0+
b110 -
#400
00
0.
1!
b1111 *
b1111 G
b1111 J
b1111 Y
b1100 H
b1100 K
b1100 R
b10000 (
b10000 ;
b10000 l
b10000 p
b10000 q
b1000000010101100 3
b1000000010101100 O
b1000000010101100 t
b0 #
b0 2
b0 {
b0 ""
b10000000101011 A
b10000000101011 N
b10000000101011 Q
b10000000101011 }
b100 "
b100 1
b100 \
b100 z
b1111 F
b1111 X
b1111 g
15
0<
0>
14
0D
b1000000010111100 I
b1000000010111100 u
b1000000010111100 #"
b10000 9
b10000 o
b10000 %"
b0 E
b0 M
b0 h
b0 ~
b10000000101011 |
b100 Z
b11 [
b101011 W
b0 f
b11 y
b111 %
b111 7
b111 L
b111 n
b111 v
b101 x
b10000 '
b10000 :
b10000 r
b10000 s
b10000 $"
b101000110010000000101011 )
b101000110010000000101011 @
b101000110010000000101011 m
b111 &
b111 8
b111 j
b111 !"
b1100 $
b1100 6
b1100 P
b1100 i
b1100 w
1+
b111 -
#450
0+
b1000 -
#500
b11 *
b11 G
b11 J
b11 Y
b110000 (
b110000 ;
b110000 l
b110000 p
b110000 q
10
b11100 3
b11100 O
b11100 t
1/
b111 A
b111 N
b111 Q
b111 }
b111 "
b111 1
b111 \
b111 z
b1 F
b1 X
b1 g
1C
04
05
b10000 H
b10000 K
b10000 R
b110000 I
b110000 u
b110000 #"
b110000 9
b110000 o
b110000 %"
b111 |
b0 Z
b111 [
b111 W
b100 f
b10000 $
b10000 6
b10000 P
b10000 i
b10000 w
b111 y
b10000 %
b10000 7
b10000 L
b10000 n
b10000 v
b111 x
b10000111001110000000000000111 )
b10000111001110000000000000111 @
b10000111001110000000000000111 m
b10100 '
b10100 :
b10100 r
b10100 s
b10100 $"
1+
b1001 -
#550
0+
b1010 -
#600
b110100 (
b110100 ;
b110100 l
b110100 p
b110100 q
b0xxxxxxxxxxxxxxxx00 3
b0xxxxxxxxxxxxxxxx00 O
b0xxxxxxxxxxxxxxxx00 t
b110100 9
b110100 o
b110100 %"
bx #
bx 2
bx {
bx ""
b0xxxxxxxxxxxxxxxx A
b0xxxxxxxxxxxxxxxx N
b0xxxxxxxxxxxxxxxx Q
b0xxxxxxxxxxxxxxxx }
bx "
bx 1
bx \
bx z
0C
bx H
bx K
bx R
bx I
bx u
bx #"
x.
x0
0/
x!
bx E
bx M
bx h
bx ~
bx |
bx Z
bx [
bx W
bx f
bx $
bx 6
bx P
bx i
bx w
bx y
bx %
bx 7
bx L
bx n
bx v
bx x
b110100 '
b110100 :
b110100 r
b110100 s
b110100 $"
bx )
bx @
bx m
1+
b1011 -
#650
0+
b1100 -
#700
b111000 (
b111000 ;
b111000 l
b111000 p
b111000 q
b111000 9
b111000 o
b111000 %"
b111000 '
b111000 :
b111000 r
b111000 s
b111000 $"
1+
b1101 -
#750
0+
b1110 -
#800
b111100 (
b111100 ;
b111100 l
b111100 p
b111100 q
b111100 9
b111100 o
b111100 %"
b111100 '
b111100 :
b111100 r
b111100 s
b111100 $"
1+
b1111 -
#850
0+
b10000 -
#900
b1000000 (
b1000000 ;
b1000000 l
b1000000 p
b1000000 q
b1000000 9
b1000000 o
b1000000 %"
b1000000 '
b1000000 :
b1000000 r
b1000000 s
b1000000 $"
1+
b10001 -
#950
0+
b10010 -
#1000
b1000100 (
b1000100 ;
b1000100 l
b1000100 p
b1000100 q
b1000100 9
b1000100 o
b1000100 %"
b1000100 '
b1000100 :
b1000100 r
b1000100 s
b1000100 $"
1+
b10011 -
#1050
b10100 -
